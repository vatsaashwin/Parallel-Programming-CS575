Last login: Sat Jun  8 12:18:20 on ttys000
AASHWINs-MacBook-Pro:~ aashwinvats$ ssh vatsa@flip.engr.oregonstate.edu
Password: 
Duo two-factor login for vatsa

Enter a passcode or select one of the following options:

 1. Duo Push to XXX-XXX-2030

Passcode or option (1-1): 1
Success. Logging you in...
Last login: Wed May 22 14:15:33 2019 from 10.248.64.2
========================================================================
This system is strictly for use by faculty, students, and staff of
       the College of Engineering, Oregon State University.

    Unauthorized access is prohibited - violators will be prosecuted

      Use should be consistent with the OSU Acceptable Use Policy
       as well as College of Engineering policies and guidelines.
  Refer to http://it.engineering.oregonstate.edu

========================================================================
   Quotas are used for home directories, incoming email, and printing.
                    For details, check:
           http://it.engineering.oregonstate.edu
------------------------------------------------------------------------
If you have any problems with this machine, please mail support@engr.orst.edu
========================================================================

perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
Terminal type? [xterm-256color] 
 02:25:10 up 70 days, 18:59, 65 users,  load average: 22.98, 22.60, 22.59
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
maxin    pts/10   24.21.225.152    00:05    1:27m  0.31s  0.18s ssh os1.engr.or
tanakae  pts/27   10.197.33.121    23:31    2:52m  0.16s  0.16s -bash
hamdaoui pts/49   24.21.124.121    02:15    9:26   1.05s  0.86s pine
vancek   pts/63   :pts/883:S.0     09May19  8:45m 12:46  11.44s SCREEN -S irc
thomtris pts/79   128.193.252.188  21:14    3:44m  1.27s  0.30s sshd: thomtris 
youja    pts/89   10.197.33.199    00:48    6:30   0.23s  0.23s -bash
tanakae  pts/93   10.197.33.121    23:46    2:38m  0.12s  0.12s -bash
garciaj3 pts/95   50.43.34.140     00:22    2:02m  0.09s  0.09s -tcsh
tanakae  pts/98   10.197.33.121    23:41    2:42m  0.13s  0.13s -bash
kwakm    pts/100  10.249.61.110    01:42   14.00s  0.32s  0.50s sshd: kwakm [pr
eldebrim pts/103  98.232.188.86    Fri18    3:00m  3.20s  3.06s ssh os2.engr.or
zhangji3 pts/119  10.197.33.174    00:42    1:41m  0.12s  0.12s -tcsh
klingma  pts/109  10.248.210.215   01:41   14:46   0.14s  0.14s -tcsh
wanal    pts/139  128.193.250.165  01:57    6:54   0.49s  0.31s vim list.cpp
zhanyunx pts/142  10.248.95.78     23:36    2:04m  0.15s  0.15s -tcsh
mcintdan pts/183  192.182.131.97   22:47    3:37m  0.10s  0.02s ssh -A -t flip
lixinwe  pts/198  10.248.182.231   02:00   30.00s  0.15s  0.15s -tcsh
varmar   pts/208  10.197.34.147    02:03   15:10   0.21s  0.21s -tcsh
pyaea    pts/212  10.248.228.222   02:11   13:10   0.26s  0.09s vim Linked_List
graymc   pts/229  10.197.33.94     17:11    4:53m  3:34m  0.22s sshd: graymc [p
wongjas  pts/281  73.240.96.37     02:24   38.00s  0.21s  0.04s ssh os1.engr.or
tanakae  pts/298  10.197.33.121    23:38    2:46m  0.12s  0.12s -bash
gutowski pts/336  10.162.4.79      31May19  5days  0.09s  0.02s ssh submit1.hpc
nguydanh pts/392  10.197.33.163    00:05    1:19m  0.27s  0.27s -bash
vatsa    pts/431  73.96.104.225    02:25    6.00s  0.17s  0.02s w
leanne   pts/464  10.217.112.66    29May19 10days  1.90s  1.79s ssh root@zen.en
yanbe    pts/509  128.193.54.168   15Apr19 55days  0.07s  0.07s -bash
nguyeta4 pts/524  10.217.112.166   Thu13   15:26m  0.56s  0.56s -csh
tanakae  pts/620  10.197.33.121    23:50    2:34m  0.14s  0.14s -bash
wrighada pts/640  98.232.67.89     Tue20    1:47m  0.52s  0.52s -tcsh
tanakae  pts/649  10.197.33.121    23:50    2:34m  0.14s  0.14s -bash
taggartk pts/650  24.19.156.246    Sat13    2:06m  0.76s  0.12s vim GameState.c
tanakae  pts/659  10.197.33.121    23:51    1:36m  0.11s  0.11s -bash
tanakae  pts/679  10.197.33.121    00:17    2:04m 20:27m  0.07s /nfs/stak/users
ekstedta pts/693  71.238.74.149    Tue13    4days  0.09s  0.09s -zsh
chenlih  pts/756  67.133.56.10     00:20    1:58m 17.73s 17.60s qemu-system-i38
tanakae  pts/766  10.197.33.121    00:18    2:05m  0.07s  0.07s -bash
harog    pts/769  108.26.192.57    29May19 10days  0.61s  0.53s vim hashMap.c
bruskea  pts/829  68.105.114.180   19:22    4:43m  0.29s  0.23s ssh rabbit.engr
lassetta pts/834  24.21.169.169    22:06    4:14m  3:07m  3:07m python rfall_mi
guz      pts/904  10.197.35.65     16:14    6:43m  0.17s  0.17s -tcsh
jonesb7  pts/913  68.96.76.142     21:28    2:44m  0.33s  0.24s sshd: jonesb7 [
houghjoh pts/918  67.177.227.63    Wed11    3days  1.34s  1.25s ssh -A os1
karras   pts/923  10.162.3.173     16May19 10days  0.20s  0.48s sshd: karras [p
giuliana pts/924  97.120.36.252    14:29    6:03m  0.29s  0.29s ssh -A os1
ekstedta pts/935  71.238.74.149    16:37    9:46m  0.00s  0.00s tmux -f cfg/tmu
willibe2 pts/936  10.248.44.59     21:36   46:46   0.54s  0.54s -tcsh
harog    pts/938  108.26.192.57    29May19 10days  0.08s  0.08s -tcsh
kuangx   pts/941  173.244.44.57    22:23    1:31m  0.38s  0.24s ssh kuangx@os1.
harog    pts/951  108.26.192.57    29May19 10days  0.17s  0.10s vim myMain.c
thomtris pts/954  128.193.252.188  21:36    4:22m  0.66s  0.45s sshd: thomtris 
tanakae  pts/965  10.197.33.121    20:27    2:08m 14.20s  0.10s -bash
tanakae  pts/978  10.197.33.121    20:59    1:37m  0.08s  0.08s -bash
benckesa pts/983  10.197.33.133    14:29    3:16m  0.78s  0.70s ssh benckesa@os
nyamogar pts/996  75.185.245.116   17:19    6:36m  0.17s  0.17s -tcsh
fisherv  pts/971  96.253.103.218   20:27    5:57m  0.04s  0.04s -tcsh
prashara pts/149  128.193.54.182   05May19 34days  0.13s  0.22s sshd: prashara 
mattsosa pts/407  128.193.249.191  18:09    6:32m  0.36s  0.29s vim testing3.cp
kitaa    pts/660  10.248.25.13     01:14    1:10m  0.40s  0.20s mongo --host cl
adamsd2  pts/662  10.197.35.85     21:30    4:54m  0.08s  0.08s -bash
mcintdan pts/725  128.193.54.168   22:47    3:37m  0.04s  0.04s ssh -A os1
lovrienj pts/268  73.67.204.137    21:51   10:30   0.17s  0.00s tmux
lamb     pts/151  128.193.249.70   Sat00    3:44m  0.65s  0.65s -tcsh
nium     pts/276  73.25.113.251    22:23    6.00s  0.65s  0.65s -bash
flip1 ~ 80% cd project7
flip1 ~/project7 81% nano openmp1.cpp
flip1 ~/project7 82% cd openmp
flip1 ~/project7/openmp 83% nano openmp1.cpp
flip1 ~/project7/openmp 84% ls
openmpmultiple  openmpmultiple.cpp  openmpsingle  openmpsingle.cpp  signal.txt
flip1 ~/project7/openmp 85% nano openmpsingle.cpp
flip1 ~/project7/openmp 86% nano openmpmultiple.cpp
flip1 ~/project7/openmp 87% cd..
cd..: Command not found.
flip1 ~/project7/openmp 88% cd ..
flip1 ~/project7 89% cd opencl
flip1 ~/project7/opencl 90% ls
AutoCorrelate.cl  CL  cl.h  cl_platform.h  opencl  opencl.cpp  signal.txt
flip1 ~/project7/opencl 91% nano opencl.cpp

  GNU nano 2.3.1                                       File: opencl.cpp                                                                                     

// 1. Program header

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#ifdef WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif
#include <omp.h>

#include "CL/cl.h"
#include "CL/cl_platform.h"

#define SIZE 32768
#define LOCAL_SIZE 32

//to check if it worked :D
float Array[2*SIZE];
float  Sums[1*SIZE];

const char *    CL_FILE_NAME = { "AutoCorrelate.cl" };
const float     TOL = 0.0001f;


void Wait( cl_command_queue );
int     LookAtTheBits( float );


int
main( int argc, char *argv[ ] )
{
        // see if we can even open the opencl kernel program
        // (no point going on if we can't):

        FILE *fp;
        #ifdef WIN32
                errno_t err = fopen_s( &fp, CL_FILE_NAME, "r" );
                if( err != 0 )
        #else
             	fp = fopen( CL_FILE_NAME, "r" );
                if( fp == NULL )
        #endif
	{
                fprintf( stderr, "Cannot open OpenCL source file '%s'\n", CL_FILE_NAME );
                return 1;
        }

	cl_int status;          // returned status from opencl calls
                                                // test against CL_SUCCESS

        // get the platform id:
        cl_platform_id platform;
        status = clGetPlatformIDs( 1, &platform, NULL );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clGetPlatformIDs failed (2)\n" );

        // get the device id:

        cl_device_id device;
        status = clGetDeviceIDs( platform, CL_DEVICE_TYPE_GPU, 1, &device, NULL );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clGetDeviceIDs failed (2)\n" );

        // 2. allocate the host memory buffers:
        FILE *sfp = fopen( "signal.txt", "r" );
        if( sfp == NULL )
                fprintf( stderr, "Cannot open file 'signal.txt'\n" );

        int Size;
        fscanf( sfp, "%d", &Size );
        float *hArray = new float[ 2*Size ];
        float *hSums  = new float[ 1*Size ];
        size_t ArraySize=2*Size*sizeof(cl_float);
        size_t SumsSize=1*Size*sizeof(cl_float);
        int i;
	// fill the host memory buffers & duplicate the array for autocorrelation function:

        for(  i = 0; i < Size; i++ )
        {
                fscanf( sfp, "%f", &hArray[i] );
                hArray[i+Size] = hArray[i];             // duplicate the array
        }
	fclose( sfp );



        // 3. create an opencl context:

        cl_context context = clCreateContext( NULL, 1, &device, NULL, NULL, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateContext failed\n" );

        // 4. create an opencl command queue:

        cl_command_queue cmdQueue = clCreateCommandQueue( context, device, 0, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateCommandQueue failed\n" );

        // 5. allocate the device memory buffers:

        cl_mem dArray = clCreateBuffer( context, CL_MEM_READ_WRITE, ArraySize, NULL, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateBuffer failed (1)\n" );

        cl_mem dSums  = clCreateBuffer( context, CL_MEM_READ_WRITE, SumsSize, NULL, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateBuffer failed (2)\n" );

	// 6. enqueue the 2 commands to write the data from the host buffers to the device buffers: 

		status = clEnqueueWriteBuffer( cmdQueue, dArray, CL_FALSE, 0, ArraySize, hArray, 0, NULL, NULL );
		if( status != CL_SUCCESS )
			fprintf( stderr, "clEnqueueWriteBuffer failed (1)\n" );

        cl_mem dSums  = clCreateBuffer( context, CL_MEM_READ_WRITE, SumsSize, NULL, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateBuffer failed (2)\n" );

        // 6. enqueue the 2 commands to write the data from the host buffers to the device buffers:

        status = clEnqueueWriteBuffer( cmdQueue, dArray, CL_FALSE, 0, ArraySize, hArray, 0, NULL, NULL );
        if( status != CL_SUCCESS )
                        fprintf( stderr, "clEnqueueWriteBuffer failed (1)\n" );

        status = clEnqueueWriteBuffer( cmdQueue, dSums, CL_FALSE, 0, SumsSize, hSums, 0, NULL, NULL );
        if( status != CL_SUCCESS )
                        fprintf( stderr, "clEnqueueWriteBuffer failed (2)\n" );

        Wait( cmdQueue );

         // create the text for the kernel program:

        char *strings[1];
        strings[0] = clProgramText;
        cl_program program = clCreateProgramWithSource( context, 1, (const char **)strings, NULL, &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateProgramWithSource failed\n" );
        delete [ ] clProgramText;

        // 8. compile and link the kernel code:

        const char *options = { "" };
        status = clBuildProgram( program, 1, &device, options, NULL, NULL );
        if( status != CL_SUCCESS )
        {
                size_t size;
                clGetProgramBuildInfo( program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &size );
                cl_char *log = new cl_char[ size ];
                clGetProgramBuildInfo( program, device, CL_PROGRAM_BUILD_LOG, size, log, NULL );
                fprintf( stderr, "clBuildProgram failed:\n%s\n", log );
                delete [ ] log;
        }

	// 9. create the kernel object:

        cl_kernel kernel = clCreateKernel( program, "AutoCorrelate", &status );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clCreateKernel failed\n" );

        // 10. setup the arguments to the kernel object:


        status = clSetKernelArg( kernel, 0, sizeof(cl_mem), &dArray );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clSetKernelArg failed (1)\n" );

        status = clSetKernelArg( kernel, 1, sizeof(cl_mem), &dSums  );
        if( status != CL_SUCCESS )
                fprintf( stderr, "clSetKernelArg failed (2)\n" );

        // 11. enqueue the kernel object for execution:

        size_t globalWorkSize[3] = { Size, 1, 1};
        size_t localWorkSize[3]  = { LOCAL_SIZE,   1, 1};

        Wait( cmdQueue );

        double time0 = omp_get_wtime( );

        time0 = omp_get_wtime( );

        status = clEnqueueNDRangeKernel( cmdQueue, kernel, 1, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL );
	if( status != CL_SUCCESS )
                {
                        fprintf( stderr, "clEnqueueNDRangeKernel failed: %d\n", status );
                }
        Wait( cmdQueue );
        double time1 = omp_get_wtime( );



       // 12. read the results buffer back from the device to the host:

        status = clEnqueueReadBuffer(cmdQueue, dArray, CL_TRUE, 0, ArraySize, hArray, 0, NULL, NULL );
        if( status != CL_SUCCESS )
                        {
                                fprintf( stderr, "clEnqueueReadBuffer failed\n" );
                        }

        status = clEnqueueReadBuffer(cmdQueue, dSums, CL_TRUE, 0, SumsSize, hSums, 0, NULL, NULL );
        if( status != CL_SUCCESS )
                        {
                                fprintf( stderr, "clEnqueueReadBuffer failed\n" );
                        }

        // Did it work?
        Wait(cmdQueue );
        int shift;
        for( shift = 0; shift < SIZE; shift++ )
        {
                float sum = 0.;
                float expected=0.;
                for( i = 0; i < SIZE; i++ )
                {
                         expected += Array[i] * Array[i + shift];
                }

                if( fabs( hSums[i] - expected ) > TOL )
                {
                        fprintf( stderr, " %13.6f * %13.6f:%4f wrongly produced %13.6f instead of %13.6f (%13.8f)\n",
                                 hArray[i], hArray[i+shift], hSums[i], expected, fabs(hSums[i]-expected) );
                        //fprintf( stderr, "%4d:    0x%08x *    0x%08x wrongly produced    0x%08x instead of    0x%08x\n",
                                //i, LookAtTheBits(hA[i]), LookAtTheBits(hB[i]), LookAtTheBits(hC[i]), LookAtTheBits(expected) );
                }
        }

	fprintf( stdout, "Performance:%lf\n", (double)(SIZE*SIZE)/(time1-time0)/1000000. );

        for( shift = 0; shift < 512; shift++ )
        {
	printf("%f\n",hSums[shift]);
        }


#ifdef WIN32
	Sleep( 2000 );
#endif


      	// 13. clean everything up:

        clReleaseKernel(        kernel   );
        clReleaseProgram(	program  );
        clReleaseCommandQueue(  cmdQueue );
        clReleaseMemObject(     dArray );
        clReleaseMemObject(     dSums  );




        delete [ ] hArray;
        delete [ ] hSums;

        return 0;
}


int LookAtTheBits( float fp ) {
        int *ip = (int *)&fp;
        return *ip;
}


// wait until all queued tasks have taken place:

void Wait( cl_command_queue queue ) {
      cl_event wait;
      cl_int	  status;

      status = clEnqueueMarker( queue, &wait );
      if( status != CL_SUCCESS )
              fprintf( stderr, "Wait: clEnqueueMarker failed\n" );

      status = clWaitForEvents( 1, &wait );
      if( status != CL_SUCCESS )
              fprintf( stderr, "Wait: clWaitForEvents failed\n" );
}


